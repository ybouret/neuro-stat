\documentclass{revtex4}

\usepackage{graphicx}
\usepackage{amssymb,amsmath}
\usepackage{epstopdf}
\usepackage{bm}
\usepackage{dsfont}
\usepackage{color}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\trn}[1]{{#1}^{\,\mathsf{T}}}

\begin{document}
\title{NeuroCorr}
\maketitle

\section{Data Description}
We have a set of $M$ trials (indexed by $j$) performed on $N$ neurones (indexed by $i$).
Each trial is a set of $N$ trains $\mathcal{T}_{j,i}$ with a
given number of spikes $S_{j,i}$ occurring a times $\tau_{j,i,q}, q\in[1:S_{j,i}]$.
Here, we will assume that the times are integer for a given time scale (millisecond, microsecond, nanosecond...).

\section{Counting interaction function}
\subsection{Description}
An counting interaction function is described by two parameters and acting on any train $\mathcal{T}_z$: a time length $\delta$ and a number
of shifts $k$ ($0\leq k < K$):
$$
	\Phi_{z,k,\delta}(t) = 
	\sum_{u\in\tau_{z}}
	 \mathds{1}_{(t-u)\in\mathbb{I}_k,\mathbb{I}_k=\rbrack k\delta,(k+1)\delta\rbrack}
$$
This expression is the number of points in $\lbrack t-(k+1)\delta,t-k\delta\lbrack$, and all the $\Phi$ functions
are hence left-continuous, constant piecewise functions.
In particular,
$$
	\Phi_{z,k,\delta}(t) = \Phi_{z,0,\delta}(t-k\delta).
$$
so we only need to compute a source function for a given train, and the following functions are computed by just
a shift in the partition.

\subsection{Implementation}
\subsubsection{Description}
We described a CPW function by a list/vector of \textbf{sorted} coordinates $\tau_i,F_i$.
and a '$\mathrm{foot}$' before the first coordinate. If the function has no coordinate, this
is the constant function...with constant value=$\mathrm{foot}$.
In summary, let $F(t)$ be a CPW function with $n_F$  coordinates and a foot value.
\begin{itemize}
	\item if $n_F=0$ then $F(t)\equiv\mathrm{foot}$.
	\item if $n_F>0$ then
	\begin{itemize}
		\item $F(t\leq\tau_0) = \mathrm{foot}$
		\item $F(\tau_{i}<t\leq\tau_{i+1}) = F_i$
		\item $F(t>\tau_{n_F-1})           = F_{n_F-1}$
	\end{itemize}
\end{itemize}

\subsubsection{Algorithm to build the source function}
Mine: Specific List Fusion + doublons removal.

\subsubsection{Evaluation}

\subsubsection{Sum over sorted times}

\subsubsection{Product construction}

\subsubsection{Integration}


\section{Boxes-wise computation}
\subsection{Using boxes}
A box $B$ is described by a trial index $j$ (with its $N$ corresponding trains, one per neurone),
a starting time $\tau_{s}$, a final time $\tau_{f}$, and a biological behaviour $\beta$.

\subsection{Right-hand column-vectors $\mu_1,\mu_2,\mu_A$}
{\bf For a given $j$}, the matrices $\mu_1$ and $\mu_2$ have $N$ columns and $1+NK$ rows,
the matrix $\mu_A$ got 1 column and $1+NK$ rows.
For each neurone $N_{j,i}$, we make a new column $\mu_{X,_i}$.
We start by collecting the list $\lambda_{j,i}=\lbrace\tau_{j,i}\in\left\rbrack\tau_s,\tau_f\right\rbrack\rbrace$,
which is a (shorter) list of sorted times.
\begin{itemize}
\item
The first line are
$$
	\mu_1(1,i) = \mu_2(1,i) = \#\lbrace\lambda_{j,i}\rbrace, \mu_A(1,1) =1.
$$
\item
The following lines are defined for each neurone $l$, using the $K$ values
$$
	\mu_1(2+(Kl)+k,i) = \sum_{\tau\in\lambda_{j,i}} \Phi_{j,l,k,\delta}(\tau)
$$
$$
	\mu_2(2+(Kl)+k,i) = \sum_{\tau\in\lambda_{j,i}} \left(\Phi_{j,l,k,\delta}(\tau)\right)^2
$$
$$
	\mu_A(2+(Kl)+k,i) = \max_{\tau\in\left\rbrack\tau_s,\tau_f\right\rbrack} \left| \Phi_{j,l,k,\delta}(\tau) \right|
$$
\item During \emph{aggregation}, by kind or by box, we add values or take the maximum value of the target matrix...
\end{itemize}

\subsection{Left-hand Symmetric Matrix $\mathcal{G}$}
\subsubsection{Definition}
The $\mathcal{G}$ matrix has $1+NK$ lines and columns.
\begin{itemize}
	\item 
		$$ 
		\mathcal{G}_{1,1} = \tau_f-\tau_s
		$$
	\item for each neurone $i$, then for each index $k$, using $I_{i,k}=1+K\times i + k$,
		\begin{itemize}
		\item compute the side terms
		$$
			\mathcal{G}_{1,I_{i,k}} = \mathcal{G}_{I_{i,k},1} = \int_{\tau_s}^{\tau_f} \Phi_{j,i,k}(\tau) \, \mathrm{d}\tau
		$$
		\item for each neurone $l\geq i$, then for each index $m$, compute the core term
		$$
			\mathcal{G}_{I_{l,m},I_{i,k}} = \mathcal{G}_{I_{i,k},I_{l,m}}  =
			\int_{\tau_s}^{\tau_f}  \Phi_{j,i,k}(\tau) \Phi_{j,l,m}(\tau) \, \mathrm{d}\tau
		$$
		\end{itemize}
\end{itemize}

\subsubsection{Evaluation}
\begin{itemize}
\item The side terms may be evaluated in parallel from the precomputed functions.

\item The core terms requires the computation of a function product, with is costly
in memory and time. So it is better to evaluate a product, and then 
every box using it perform its own evaluation.
 The parallelism occurs
on the computation of the different products.
\end{itemize}

\section{Finding coefficients}
For each columns $\vec{b}$ and $\vec{v}$ of $\mu_1$ and $\mu_2$ respectively, and we search the $p=1+NK$ parameters $\vec{a}$ which minimizes
\begin{equation}
	\mathcal{H}\left(\vec{a}\right) = -2\trn{\vec{b}}\vec{a} + \trn{\vec{a}} \mathcal{G} \vec{a} +2 \trn{\vec{d}} \abs{\vec{a}}
\end{equation}
with, using $\vec{A}$ as the one column of $\mu_A$, 
\begin{equation}
	\vec{d} = \sqrt{2\gamma \ln p \cdot \vec{v}} + \dfrac{\gamma\ln p}{3} \vec{A}. 
\end{equation}
Let us use the diagonal matrix 
$\bm{\sigma}\left(\vec{a}\right)$ defined by
\begin{equation}
	\sigma_{i}\left({\vec{a}}\right) = \left\lbrace
	\begin{array}{rl}
	-1 & \text{if $a_i<0$}\\
	0  & \text{if $a_i=0$}\\
	1  & \text{if $a_i>0$}\\
	\end{array}
	\right.
	.
\end{equation}
We may write
\begin{equation}
	\mathcal{H}\left(\vec{a}\right) = -2\trn{\vec{b}}\vec{a} + \trn{\vec{a}} \mathcal{G} \vec{a} + 2 \trn{\vec{d}} \bm{\sigma}\left(\vec{a}\right) \vec{a}
\end{equation}
or
\begin{equation}
	\mathcal{H}\left(\vec{a}\right) = 2\trn{\vec{a}}\left(\bm{\sigma}\left({\vec{a}}\right)\vec{d}-\vec{b}\right) +  \trn{\vec{a}} \mathcal{G} \vec{a}.
\end{equation}
The gradient of
  $\mathcal{H}$  is proportional to
\begin{equation}
	\vec{q} = \bm{\sigma}\left({\vec{a}}\right) \vec{d} -\vec{b} + \mathcal{G} \vec{a}.
\end{equation}
During the process, we are not allowed to "cross" $0$ for any $\vec{a}$ coordinate, since it will change $\bm{\sigma}$ \textcolor{red}{(is that true?)}.\\
Starting from $\vec{a}=\vec{0}$, one will stay there if $\vec{b}=\vec{0}$ !!
 

\end{document}
